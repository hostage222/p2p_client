/**
 * @file
 * @brief Заголовочный файл с описанием класса p2p::client
 */
#ifndef P2P_CLIENT_H
#define P2P_CLIENT_H

#include <string>
#include <vector>
#include <map>
#include <memory>

#include "p2p_common.h"
#include "p2p_events.h"

/**
 * @brief Пространство имён, содержащее реализацию p2p-мессенджера
 */
namespace p2p
{

/**
 * @brief Класс p2p-мессенджера
 */
class client : public std::enable_shared_from_this<client>
{
public:
    /**
     * @brief Умный указатель (с подсчётом ссылок) на объект класса
     */
    using ptr = std::shared_ptr<client>;
    /**
     * @brief Создать объект
     *
     * Конструктор класса является приватным, прямое создание запрещено
     * из-за особенностей функционирования класса std::enable_shared_from_this
     *
     * @return Указатель на созданный объект класса
     */
    static ptr create();

    /**
     * @brief Установить соединение с сервером; блокирующий метод
     *
     * Если соединение уже установлено, ничего не делает
     *
     * @param[in] address Адрес сервера
     * @return Успешность установки соединения с сервером
     */
    bool connect_to_server(std::string address);

    /**
     * @brief Закрытие соединение с сервером и всеми контактами;
     * неблокирующий метод
     *
     * Если соединение не было устанолвено, ничего не делает;
     * если соединение было установлено, закрывает его и генерирует событие
     * disconnected_event
     */
    void close_all_connections();

    /**
     * @brief Список телефонов
     */
    using phones_list = std::vector<std::string>;
    /**
     * @brief Ассоциативный массив, ставящий в соответствие уникальный
     * идентификатор контакта его номеру телефона
     *
     * Ключ - телефон, значение - уникальный идентификатор
     */
    using contacts_dictionary = std::map<std::string, friend_id_type>;
    /**
     * @brief Запросить уникальные идентификаторы пользователей по их номерам
     * телефона; метод блокирующий
     *
     * @param[in] phones Список телефонов
     * @return Ассоциативный массив, содержащий в качестве ключей номера
     * телефонов контактов, а в качестве значений уникальные идентификаторы
     * контактов; результат включает в себя только тех ползователей, которые
     * были зарегистрированы на сервере; если соединение с сервером не было
     * установлено или было разорвано во время выполнения метода, возвращаемое
     * значение будет пустым
     */
    contacts_dictionary get_contacts(const phones_list &phones);

    /**
     * @brief Запросить необработанное событие; метод блокирующий
     * @return Указатель на событие
     */
    event::ptr get_event();

    /**
     * @brief Запросить соединение с контактом; неблокирующий метод
     *
     * Если соединение с выбранным контактом уже запрошено, либо уже
     * установлено, или связь с сервером не была установлена, метод ничего
     * не делает; связанные события: friend_confirmed_connection_event,
     * friend_discarded_connection_event, friend_connected_event,
     * friend_disconnected_event
     *
     * @param[in] friend_id Уникальный идентификатор контакта
     */
    void connect_to_client(friend_id_type friend_id);

    /**
     * @brief Согласиться принять соденинение с контактом; неблокирующий метод
     *
     * Если запрос на соединение от указанного контакта не был ранее получен,
     * либо соединение уже установлено, или связь с сервером не была
     * установлена, метод ничего не делает; связанные события:
     * friend_connected_event, friend_disconnected_event
     *
     * @param[in] friend_id Уникальный идентификатор контакта
     */
    void confirm_connection(friend_id_type friend_id);

    /**
     * @brief Отказаться принимать соединение с контактом; неблокирующий метод
     *
     * Если запрос на соединение от указанного контакта не был ранее получен,
     * либо соединение уже установлена, или связь с сервером не была
     * установлена, метод ничего не делает
     *
     * @param[in] friend_id Уникальный идентификатор контакта
     */
    void discard_connection(friend_id_type friend_id);

    /**
     * @brief Закрыть соединение с контактом или отказаться от соединения;
     * неблокирующий метод
     *
     * Если метод был вызван после вызова client::connect_to_client,
     * но до установки соединения с контактом, указанному контакту
     * будет передано сообщение об отказе установки соединения;
     * если метод был вызван после устанавки соединения,
     * соединение будет закрыт; во всех остальных случае, или если соединение
     * с сервером не было установлено, метод ничего не делает; связанное
     * событие - friend_disconnected_event
     *
     * @param[in] friend_id Уникальный идентификатор контакта
     */
    void close_client_connection(friend_id_type friend_id);

    /**
     * @brief Послать сообщение контакту
     *
     * После того как сообщение будет доставлено, генерируется событие
     * friend_message_delivered_event; сообщение может быть недоставлено
     * только если потеряна связь с контактом
     *
     * @param[in] friend_id Уникальный идентификатор контакта
     * @param[in] message Текст сообщения
     * @return Уникальный (для текущего объекта клиента) идентификатор
     * сообщения
     */
    message_id_type send_message(friend_id_type friend_id,
                                 const std::string &message);

private:
    client();
};

}

#endif // CLIENT_H
